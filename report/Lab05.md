# Lab05 Copy-on-Write Fork for xv6

## Implement copy-on write

### 实验目的

#### 问题

xv6中的`fork()`系统调用将父进程的所有用户空间内存复制到子进程中。如果父进程较大，则复制可能需要很长时间。更糟糕的是，这项工作经常造成大量浪费；例如，子进程中的`fork()`后跟`exec()`将导致子进程丢弃复制的内存，而其中的大部分可能都从未使用过。另一方面，如果父子进程都使用一个页面，并且其中一个或两个对该页面有写操作，则确实需要复制。

#### 解决方案

copy-on-write (COW) fork()的目标是推迟到子进程实际需要物理内存拷贝时再进行分配和复制物理内存页面。

COW fork()只为子进程创建一个页表，用户内存的PTE指向父进程的物理页。COW fork()将父进程和子进程中的所有用户PTE标记为不可写。当任一进程试图写入其中一个COW页时，CPU将强制产生页面错误。内核页面错误处理程序检测到这种情况将为出错进程分配一页物理内存，将原始页复制到新页中，并修改出错进程中的相关PTE指向新的页面，将PTE标记为可写。当页面错误处理程序返回时，用户进程将能够写入其页面副本。

COW fork()将使得释放用户内存的物理页面变得更加棘手。给定的物理页可能会被多个进程的页表引用，并且只有在最后一个引用消失时才应该被释放。

### 实验内容

1. 在`kernel/riscv.h`中定义`PTE_F`标记一个页面是否为COW Fork的标志位。
2. 在`kernel/kalloc.c`中进行修改：
   1. 定义引用计数的全局变量`ref`。有一个自旋锁和一个引用计数的数组，并在`kint()`中初始化该自旋锁。
   2. 修改`kalloc`和`kfree`函数，在`kalloc`中初始化内存引用计数为1，在`kfree`函数中对内存引用计数减1，如果引用计数为0时才真正删除。
   3. 添加`cowpage(pagetable_t, uint64)`，功能为判断一个页面是否为COW页面，具体步骤为：获取pte，检查`PTE_V`是否为1（是否合法pte），返回`PTE_F`的值。
   4. 添加`cowalloc(pagetable, uint64)`，功能为cow分配器。具体步骤为：获取对应物理地址；获取对应PTE；获取引用计数，若引用计数为1则直接修改对应PTE，若引用计数大于1则分配页面并拷贝旧页面内容；清除PTE_V，防止remap；为新页面添加映射；将原来的物理内存引用计数减一。
   5. 添加`krefcnt(void *pa)`，功能为获取内存的引用计数`ref.cnt[(uint64)pa / PGSIZE]`。
   6. 添加`kaddrefcnt(void *pa)`，功能为添加内存的引用计数。操作为上锁后对ref中引用计数变量+1
   7. 将这四个函数在`kernel/defs.h`中声明。
   8. 修改`freerange`函数，注意在free前对引用计数置一后再kfree。
3. 修改uvmcopy，不为子进程分配内存，而是使父进程共享内存。但禁用`PTE_W`，同时标记`PTE_F`，最后调用`kaddrefcnt`增加引用计数。
4. 修改usertrap，处理错误页面。
5. 在copyout中处理相同的情况，如果是COW页面，需要更换`pa0`指向的物理地址。

### 遇到的问题和解决方法

对写时拷贝不太理解，通过实验的解释了解了写时拷贝的原理，并了解了其逻辑——引用计数。通过对页面的引用计数，操作系统可以判断那些页可以被回收。在写的过程中，由于没有把引用计数置一，所有在释放时把它减到了负数。另外，思考引用计数数组如何索引，确保正确性的操作花了一些时间。写时拷贝涉及fork的全流程，所以在写的时候有很多顾虑，后来在实验指导的提示下一步步解决了问题。

### 实验心得

这个实验让我对写时拷贝（COW）有了更深入的理解。我学会了如何通过引用计数来推迟内存复制，从而提高系统的性能和效率。同时，我也学会了在实现写时拷贝时，要注意引用计数数组的正确索引和页面错误处理等细节。这个实验让我明白操作系统的优化是复杂的，对程序员来说明白要干什么比写代码更重要。通过这个实验，我不仅提高了对写时拷贝的理解，还加深了对操作系统内核编程的认识。这个实验对我来说是一个很好的学习机会，让我更加深入地了解了操作系统的工作原理和优化技术。

### 实验截图

![cow](..\src\Lab05\cow.bmp "cow实验截图")

## Make grade截图

![grade-lab05](..\src\Lab05\grade-lab05.bmp "lab05 grade")

## 代码位置

`kernel/riscv.h` col: 346

`kernel/kalloc.c` col: 17, 36,  41，129

`kernel/vm.c` col: 332

`kernel/trap.c` col: 37

`kernel/vm,c` col: 380
