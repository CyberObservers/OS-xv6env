# Lab10 mmap

## mmap

### 实验目的

本实验的主要目标是实现一个内存映射文件的功能，通过将文件映射到进程的地址空间中，从而在与文件交互时极大地减少磁盘操作的需求。内存映射文件是一种高效的文件访问方式，它允许程序直接访问文件在内存中的副本，而无需频繁地进行读取或写入磁盘操作，从而提高了文件访问的速度和效率。

### 实验内容

1. 配置系统调用`mmap`和`munmap`。
2. 在`kernel/proc.h`中定义VMA结构体，并添加到PCB中。
3. 在allocproc中将vma数组初始化为全0。
4. 根据提示2、3、4，将当前`p->sz`作为分配的虚拟起始地址，但不实际分配物理页面，实现`mmap`。此函数写在`sysfile.c`中就可以使用静态函数`argfd`同时解析文件描述符和`struct file`。
5. 根据提示5，此时访问对应的页面就会产生页面错误，需要在`usertrap`中进行处理，主要完成三项工作：分配物理页面，读取文件内容，添加映射关系。
   1. 在usertrap中，读取产生页面故障的虚拟地址，并判断是否位于有效区间。若在，尝试修复（调用自定义函数）。若不成功则kill进程；若不在，直接kill进程。
   2. 实现上述自定义函数`mmap_handler`。

6. 根据提示6实现`munmap`，且提示7中说明无需查看脏位就可写回。
7. 如果对惰性分配的页面调用了`uvmunmap`，或者子进程在fork中调用`uvmcopy`复制了父进程惰性分配的页面都会导致panic，因此需要修改`uvmunmap`和`uvmcopy`检查`PTE_V`后不再`panic`。
8. 根据提示8修改`exit`，将进程的已映射区域取消映射。
9. 根据提示9，修改`fork`，复制父进程的VMA并增加文件引用计数。

### 遇到的问题和解决方法

代码位置涉及多个文件，所有涉及跨文件的宏定义。结果是在编译时疯狂报错。解决方法是不断根据错误include，但似乎内核态头文件有不同的包含方式。在include后内核态头文件会报错，来回捣鼓了一会才搞定。

但上面的还是小问题。2021的实验没有lazy实验，所以为了实现“惰性地填写页表，以相应页错误”费了一番功夫。例如没有更改`uvmunmap`和`uvmcopy`检查`PTE_V`后不再`panic`导致出现panic的情况等等。

### 实验心得

之前很多实验都是实现操作系统的功能，而这个实验是对文件系统进行优化。造轮子相比优化轮子更难，因为既要让原有代码正确运行，又要实现性能的提高。对于xv6这样的教学用操作系统尚且困难，对Windows这种复杂的操作系统想必更难维护和优化。

## Make Grade

![grade-lab10](..\src\Lab10\grade-lab10.bmp)

## 代码位置

`kernel/proc.h`: 87

`kernel/sysfile.c`: 488, 540

`kernel/trap.c`: 36, 132

`kernel/proc.c`: 366
