# Lab08 locks

## Memory allocator

### 实验目的

本实验完成的任务是为每个CPU都维护一个空闲列表，初始时将所有的空闲内存分配到某个CPU，此后各个CPU需要内存时，如果当前CPU的空闲列表上没有，则窃取其他CPU的。例如，所有的空闲内存初始分配到CPU0，当CPU1需要内存时就会窃取CPU0的，而使用完成后就挂在CPU1的空闲列表，此后CPU1再次需要内存时就可以从自己的空闲列表中取。

### 实验内容

1. 将`kmem`定义为一个数组，包含`NCPU`个元素，即每个CPU对应一个
2. 修改`kinit`，为所有锁初始化以“kmem”开头的名称，该函数只会被一个CPU调用，`freerange`调用`kfree`将所有空闲内存挂在该CPU的空闲列表上
3. 修改`kfree`，使用`cpuid()`和它返回的结果时必须关中断
4. 修改`kalloc`，使得在当前CPU的空闲列表没有可分配内存时窃取其他内存的

### 遇到的困难和解决方法

在kalloc和kfree中没有关中断，导致在`writebig`中出现`panic: balloc: out of blocks`。关中断的作用是使操作具有原子性，防止出现在释放时切换进程而可能导致的块不够的问题。通过阅读hint了解到需要添加关中断与开中断。

不太会用snprintf进行字符串格式化，通过阅读源码解决。

### 实验心得

通过这个实验，我学会了如何在多CPU环境下共享内存分配器，并了解了处理中断和原子操作的重要性。我理解了关中断的作用，以及如何确保操作的原子性以避免竞态条件和错误。在实验中，应该确保在分配和释放内存时，只操作当前CPU的空闲列表，并在需要时窃取其他CPU的内存。我对多个CPU之间的同步和共享问题有了更深入的理解。

### 实验截图

![kalloctest](..\src\Lab08\kalloctest.bmp)

## Buffer cache

### 实验目的

如果多个进程密集地使用文件系统，它们可能会争夺`bcache.lock`，它保护`kernel/bio.c`中的磁盘块缓存。修改块缓存，以便在运行`bcachetest`时，buffer cache中所有锁的`acquire`循环迭代次数接近于零。修改`bget`和`brelse`，以便buffer cache中不同块的并发查找和释放不太可能在锁上发生冲突。

### 实验内容

1. 定义哈希桶结构，并在`bcache`中删除全局缓冲区链表，改为使用素数个散列桶
2. 在`binit`中:
   1. 初始化散列桶的锁
   2. 将所有散列桶的`head->prev`、`head->next`都指向自身表示为空
   3. 将所有的缓冲区挂载到`bucket[0]`桶上
3. 在`buf.h`中增加新字段`timestamp`。在原始方案中，每次`brelse`都将被释放的缓冲区挂载到链表头，禀明这个缓冲区最近刚刚被使用过，在`bget`中分配时从链表尾向前查找，这样符合条件的第一个就是最久未使用的。而在提示中建议使用时间戳作为LRU判定的法则，这样我们就无需在`brelse`中进行头插法更改结点位置
4. 更改`brelse`，不再获取全局锁
5. 更改`bget`，当没有找到指定的缓冲区时进行分配，分配方式是优先从当前列表遍历，找到一个没有引用且`timestamp`最小的缓冲区，如果没有就申请下一个桶的锁，并遍历该桶，找到后将该缓冲区从原来的桶移动到当前桶中，最多将所有桶都遍历完。在代码中要注意锁的释放
6. 最后将`bpin`和`bunpin`修改，获取对应哈希桶的锁，对对应哈希桶进行操作。

### 遇到的困难和解决方法

1. 哈希桶设置为13时出现`panic`，原因是xv6系统中块不足了。于是减少哈希桶到5，但一直不行。第二天再试突然行了，猜测`make clean`后再`make qemu`应该可以。但是在`make grade`中第一个测试失败了。将哈希桶设置为7后所有测试通过。
2. 在bget时发生了死锁。因为bget中重新分配可能要持有两个锁，如果桶a持有自己的锁，再申请桶b的锁，与此同时如果桶b持有自己的锁，再申请桶a的锁就会造成死锁。解决方法是加入检查语句：`if(!holding(&bcache.bucket[i].lock))`。为了避免频繁的跨桶获取缓冲区，规定优先从自身的桶中获取。

### 实验心得

通过这个实验，我学到了如何优化多个进程对块缓存的访问，以减少锁的竞争和冲突。我深入理解了哈希桶的概念以及如何在多CPU环境下进行锁的获取和释放，以确保并发访问的正确性和性能。在解决困难的过程中，我不仅提高了对操作系统内核编程和并发访问的理解，还锻炼了调试和优化的能力。这个实验让我更加深入地了解了操作系统内部的工作原理。

### 实验截图

![bcachetest](..\src\Lab08\bcachetest.bmp)

## Make grade

![grade-lab08](..\src\Lab08\grade-lab08.bmp)

## 代码位置

**Memory allocator**

`kernel/kalloc.c`: 24, 28, 56, 84

**Buffer cache**

`kernel/bio.c`: 26, 45, 

`kernel/buf.h`: 12, 61, 133, 152, 162







